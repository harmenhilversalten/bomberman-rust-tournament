### Engine Crate (`bomberman_engine`)

#### Module Structure
```
bomberman_engine/
├── lib.rs                 // Crate public interface
├── engine/                // Core engine implementation
│   ├── mod.rs
│   ├── game_engine.rs     // Main engine structure
│   ├── scheduler.rs       // Task scheduling
│   └── timing.rs          // Timing and tick management
├── systems/               // Engine systems
│   ├── mod.rs
│   ├── movement.rs        // Movement system
│   ├── bomb_system.rs     // Bomb management system
│   ├── explosion.rs       // Explosion system
│   ├── powerup.rs         // Powerup system
│   └── player.rs          // Player management system
├── simulation/            // Simulation management
│   ├── mod.rs
│   ├── sim_controller.rs  // Simulation controller
│   ├── replay.rs          // Replay system
│   └── determinism.rs     // Determinism verification
├── config/                // Configuration
│   ├── mod.rs
│   ├── engine_config.rs   // Engine configuration
│   └── game_rules.rs      // Game rules
└── tests/                 // Unit and integration tests
    ├── mod.rs
    ├── engine_tests.rs
    └── simulation_tests.rs
```

#### Core Data Structures

```rust
// Main game engine structure
pub struct GameEngine {
    config: EngineConfig,
    state: GameState,
    systems: Vec<Box<dyn System>>,
    event_bus: EventBus,
    scheduler: TaskScheduler,
    timing: TimingManager,
    replay_recorder: ReplayRecorder,
    determinism_checker: DeterminismChecker,
}

// Task scheduler for parallel system execution
pub struct TaskScheduler {
    runtime: tokio::runtime::Runtime,
    task_queue: SegQueue<Box<dyn Task>>,
    worker_pool: WorkerPool,
    system_dependencies: DependencyGraph,
}

// Timing manager for tick-based simulation
pub struct TimingManager {
    tick_duration: Duration,
    last_tick: Instant,
    tick_number: u64,
    max_frame_time: Duration,
}

// System trait for engine systems
pub trait System: Send + Sync {
    fn name(&self) -> &str;
    fn run(&mut self, state: &mut GameState, event_bus: &mut EventBus) -> Result<(), EngineError>;
    fn dependencies(&self) -> &[SystemName] { &[] }
    fn parallelizable(&self) -> bool { false }
}

// Movement system for entity movement
pub struct MovementSystem {
    config: MovementConfig,
    path_cache: LruCache<EntityId, Path>,
    pending_moves: HashMap<EntityId, MoveRequest>,
}

// Bomb system for bomb management
pub struct BombSystem {
    config: BombConfig,
    active_bombs: HashMap<EntityId, Bomb>,
    bomb_chains: Graph<BombId, BombChainEdge>,
    explosion_queue: PriorityQueue<ExplosionEvent, u8>,
}
```

#### Key Algorithms

1. **Game Loop**
   - Fixed timestep game loop with interpolation
   - Parallel system execution where possible
   - Event processing between systems

```rust
impl GameEngine {
    pub fn run(&mut self) -> Result<(), EngineError> {
        self.timing.reset();
        
        loop {
            let frame_start = Instant::now();
            
            // Process input events
            self.process_events()?;
            
            // Run fixed timestep simulation
            self.run_fixed_timestep()?;
            
            // Render with interpolation
            self.render()?;
            
            // Frame timing and sleep
            let frame_time = frame_start.elapsed();
            if frame_time < self.timing.target_frame_time() {
                std::thread::sleep(self.timing.target_frame_time() - frame_time);
            }
            
            // Check for exit condition
            if self.should_exit() {
                break;
            }
        }
        
        Ok(())
    }
    
    fn run_fixed_timestep(&mut self) -> Result<(), EngineError> {
        let mut accumulator = self.timing.accumulator();
        
        while accumulator >= self.timing.tick_duration() {
            // Start of tick
            self.timing.start_tick();
            
            // Record state for determinism checking
            if self.determinism_checker.enabled() {
                self.determinism_checker.record_state(&self.state);
            }
            
            // Run systems in dependency order
            self.run_systems()?;
            
            // Process events generated by systems
            self.process_system_events()?;
            
            // Record frame for replay
            if self.replay_recorder.recording() {
                self.replay_recorder.record_frame(&self.state);
            }
            
            // End of tick
            self.timing.end_tick();
            accumulator -= self.timing.tick_duration();
        }
        
        self.timing.set_accumulator(accumulator);
        Ok(())
    }
}
```

2. **Bomb Chain Reaction Calculation**
   - Graph-based analysis of bomb chains
   - Efficient propagation of explosion effects
   - Early termination for performance

```rust
impl BombSystem {
    pub fn calculate_chain_reactions(&mut self, state: &GameState) -> Result<(), BombError> {
        // Build bomb adjacency graph
        self.build_bomb_graph(state)?;
        
        // Find connected components (chains)
        let chains = self.find_bomb_chains();
        
        // Calculate explosion timing for each chain
        for chain in chains {
            self.calculate_chain_timing(chain)?;
        }
        
        Ok(())
    }
    
    fn build_bomb_graph(&mut self, state: &GameState) -> Result<(), BombError> {
        self.bomb_chains.clear();
        
        // Get all bombs from state
        let bomb_entities = state.query::<With<Bomb>>();
        
        // Create nodes for each bomb
        for entity_id in bomb_entities {
            let bomb = state.get_component::<Bomb>(entity_id)
                .ok_or(BombError::BombNotFound(entity_id))?;
            let position = state.get_component::<Position>(entity_id)
                .ok_or(BombError::PositionNotFound(entity_id))?;
            
            let bomb_id = BombId::new(entity_id);
            self.bomb_chains.add_node(bomb_id, bomb.clone());
            
            // Check for adjacency with other bombs
            for (other_id, other_bomb) in &self.active_bombs {
                if entity_id == *other_id {
                    continue;
                }
                
                let other_position = state.get_component::<Position>(*other_id)
                    .ok_or(BombError::PositionNotFound(*other_id))?;
                
                // Check if bombs are in explosion range
                if self.bombs_in_range(position, other_position, bomb.power) {
                    self.bomb_chains.add_edge(
                        bomb_id,
                        BombId::new(*other_id),
                        BombChainEdge::new(bomb.timer),
                    );
                }
            }
        }
        
        Ok(())
    }
}
```

#### Performance Optimizations

1. **Parallel System Execution**: Execute independent systems in parallel using Tokio tasks.

2. **Batched Entity Processing**: Process entities in batches to improve cache locality.

3. **Event Coalescing**: Combine similar events to reduce processing overhead.

4. **Lazy State Updates**: Only update state when necessary, using dirty flags.

5. **Memory Pooling**: Reuse memory allocations for frequently created/destroyed objects.

#### API Design

```rust
// Main public interface for the engine crate
pub struct GameEngineBuilder {
    config: EngineConfig,
    state: Option<GameState>,
    systems: Vec<Box<dyn System>>,
}

impl GameEngineBuilder {
    pub fn new() -> Self { /* ... */ }
    
    pub fn config(mut self, config: EngineConfig) -> Self { /* ... */ }
    
    pub fn state(mut self, state: GameState) -> Self { /* ... */ }
    
    pub fn add_system<S: System + 'static>(mut self, system: S) -> Self { /* ... */ }
    
    pub fn build(self) -> Result<GameEngine, EngineError> { /* ... */ }
}

impl GameEngine {
    /// Create a new game engine with default configuration
    pub fn new() -> Result<Self, EngineError> {
        GameEngineBuilder::new().build()
    }
    
    /// Run the game engine
    pub fn run(&mut self) -> Result<(), EngineError> { /* ... */ }
    
    /// Get a reference to the current game state
    pub fn state(&self) -> &GameState {
        &self.state
    }
    
    /// Get a mutable reference to the current game state
    pub fn state_mut(&mut self) -> &mut GameState {
        &mut self.state
    }
    
    /// Add an event to the event bus
    pub fn emit_event(&mut self, event: GameEvent) {
        self.event_bus.emit(event);
    }
    
    /// Start recording a replay
    pub fn start_replay_recording(&mut self) -> Result<(), EngineError> {
        self.replay_recorder.start_recording(&self.state)
    }
    
    /// Stop recording and save the replay
    pub fn stop_replay_recording(&mut self) -> Result<Replay, EngineError> {
        self.replay_recorder.stop_recording()
    }
}
```

#### Error Handling Strategy

```rust
/// Errors that can occur in engine operations
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum EngineError {
    /// State error
    State(StateError),
    /// System error
    System(SystemError),
    /// Timing error
    Timing(TimingError),
    /// Replay error
    Replay(ReplayError),
    /// Determinism error
    Determinism(DeterminismError),
    /// Configuration error
    Config(ConfigError),
    /// Initialization error
    Initialization(String),
    /// Runtime error
    Runtime(String),
}

impl fmt::Display for EngineError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            EngineError::State(err) => write!(f, "State error: {}", err),
            EngineError::System(err) => write!(f, "System error: {}", err),
            EngineError::Timing(err) => write!(f, "Timing error: {}", err),
            EngineError::Replay(err) => write!(f, "Replay error: {}", err),
            EngineError::Determinism(err) => write!(f, "Determinism error: {}", err),
            EngineError::Config(err) => write!(f, "Configuration error: {}", err),
            EngineError::Initialization(msg) => write!(f, "Initialization error: {}", msg),
            EngineError::Runtime(msg) => write!(f, "Runtime error: {}", msg),
        }
    }
}
```

#### Testing Strategy

1. **Unit Tests**
   - Test individual systems in isolation
   - Verify timing and scheduling
   - Test event processing

2. **Integration Tests**
   - Test engine with mock systems
   - Verify replay recording and playback
   - Test determinism checking

3. **Property-Based Tests**
   - Generate random event sequences
   - Verify engine invariants
   - Test replay consistency

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use proptest::prelude::*;
    
    #[test]
    fn test_engine_creation() {
        let engine = GameEngine::new().unwrap();
        
        assert_eq!(engine.config().tick_rate, 60);
        assert!(!engine.replay_recorder().recording());
        assert!(!engine.determinism_checker().enabled());
    }
    
    proptest! {
        #[test]
        fn test_replay_consistency(
            seed in any::<u64>(),
            tick_count in 1u64..100u64,
        ) {
            let mut engine = GameEngine::new().unwrap();
            engine.state_mut().set_seed(seed);
            
            // Record replay
            engine.start_replay_recording().unwrap();
            for _ in 0..tick_count {
                engine.run_single_tick().unwrap();
            }
            let replay = engine.stop_replay_recording().unwrap();
            
            // Reset engine
            let mut engine = GameEngine::new().unwrap();
            engine.state_mut().set_seed(seed);
            
            // Record initial state hash
            let initial_hash = engine.state().hash();
            
            // Play replay
            engine.load_replay(replay).unwrap();
            for _ in 0..tick_count {
                engine.run_single_tick().unwrap();
            }
            
            // Verify final state hash matches
            assert_eq!(engine.state().hash(), initial_hash);
        }
    }
}
```

