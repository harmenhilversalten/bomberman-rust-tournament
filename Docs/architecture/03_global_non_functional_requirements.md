## 3. Global Non-Functional Requirements

### 3.1 Performance and Resource Constraints

The AI architecture is subject to stringent performance and resource constraints to ensure a responsive and scalable system, particularly when dealing with a large number of agents in extensive game worlds. The primary performance metric is Throughput, defined as a median decision time of ≤ 1 ms per bot per tick on a 256×256 map, utilizing a single 3 GHz core. This ensures that even with hundreds of bots, the AI processing does not become a bottleneck for the game's 60 Hz simulation rate. Complementing throughput, Latency is also critical, with a requirement that the 95th percentile decision time remains < 2 ms. This ensures that even in complex scenarios, most agents can make timely decisions. In terms of memory, each bot is limited to 16 MB, encompassing all its internal data structures, including maps, caches, and search trees. This constraint is vital for supporting large-scale simulations with many agents without exhausting system memory. For RL agents, these limits must also accommodate the memory footprint of neural network models, which are expected to be relatively small (e.g., 1-5 MB).

### 3.2 Determinism and Safety

Determinism and safety are paramount in the design of this AI architecture. Determinism is crucial for several reasons: it enables bit-identical replays when the same Random Number Generator (RNG) seeds and inputs are used, which is invaluable for debugging, testing, and analyzing agent behavior. For Reinforcement Learning, determinism in the environment (outside of agent exploration) is often preferred for reproducible training runs and reliable evaluation. While the core game mechanics and environment updates will be deterministic, stochastic policies used during RL exploration will require carefully managed, seeded RNG to ensure that any non-determinism is controlled and reproducible. Safety is addressed by strictly adhering to Rust's memory safety guarantees. The architecture mandates no use of unsafe Rust code beyond well-defined Foreign Function Interface (FFI) boundaries, and the entire codebase should be fully Miri-compatible. Miri is an experimental Rust interpreter that can detect certain classes of undefined behavior, providing an additional layer of confidence in the code's correctness and safety. This focus on safety prevents common bugs such as null pointer dereferencing, data races, and buffer overflows, which is especially important in a complex, concurrent system.

### 3.3 Extensibility and Modularity

The architecture prioritizes extensibility and modularity to accommodate future developments and diverse experimentation. A key requirement is the ability to add new game elements, such as power-ups or modified game rules, with minimal changes to core modules. This is quantified by the goal of implementing such additions in fewer than 100 lines of code, primarily by leveraging trait-based interfaces and a plugin system. This low barrier to modification encourages experimentation and rapid iteration. The modular design, with clearly defined interfaces between components (e.g., state, engine, influence, path, goals, bombs, bot crates), allows developers to work on individual parts of the AI system independently. This separation of concerns simplifies understanding, testing, and replacing components without affecting others. Furthermore, the architecture has been enhanced with specific hooks for Reinforcement Learning (RL) integration. This includes well-defined interfaces for loading NN policies, performing batched inference for efficiency, and managing RL-specific data like observations and rewards. This foresight in design ensures that the system can evolve beyond purely programmatic AI to incorporate sophisticated learning-based agents seamlessly.

---

